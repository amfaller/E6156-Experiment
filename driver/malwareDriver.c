
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/module.h>
#include <linux/syscalls.h>
#include <linux/fcntl.h>
#include <linux/fs.h>
#include <linux/types.h>
#include <linux/dcache.h>
#include <linux/dirent.h>
#include <linux/proc_fs.h>
#include <linux/slab.h>
#include <asm/uaccess.h>

// To demonstrate that the driver itself is malware
#define SECRET_PATH "/home/tony/Documents/mySecret.txt"
#define BUFFER_SIZE 512

// To demonstrate that kernel-level processes can be deceived by a userspace program
#define TARGET_DIR "/home/tony/Documents"
#define TARGET_FILES "cheat1.txt", "cheat2.txt"
#define PROC_FILE_NAME "ScanResults"

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Demonstrate that the driver itself can act as malware.
//
// Function which reads at most BUFFER_SIZE bytes from the file at SECRET_PATH.
// Note that reading files in the kernel is EXTREMELY DANGEROUS!!!
// Please see this blog post for further detail: linuxjournal.com/article/8110
//////////////////////////////////////////////////////////////////
static void readFile(void)
{
  struct file* filePtr;
  char* buf;
  loff_t pos = 0;
  ssize_t bytesRead;
  printk(KERN_DEBUG);
  
  buf= kmalloc(BUFFER_SIZE, GFP_KERNEL);
  if (!buf)
  {
    printk("Error: Failed to allocate memory\n");
    return;
  }
  
  filePtr = filp_open(SECRET_PATH, O_RDONLY, 0);
  if (IS_ERR(filePtr))
  {
    printk("Error: Failed to open file %s\n", SECRET_PATH);
    return;
  }
  
  bytesRead = kernel_read(filePtr, buf, BUFFER_SIZE-1, &pos);
  if (bytesRead > 0)
  {
    buf[bytesRead] = '\0';
    printk("Contents of %s:\n%s\n", SECRET_PATH, buf);
  }
  else
  {
    printk("Error: Failed to read file %s\n", SECRET_PATH);
  }
  
  filp_close(filePtr, NULL);
  kfree(buf);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Demonstrate that the driver's intended purpose can be defeated.

static char scanResults[1024];
static int resultsLen;

////////////////////////////////////////////////////////////////
// This function is called on a per-file basis. It's not called
// directly here, but rather it is used by the kernel under-the-hood.
////////////////////////////////////////////////////////////////
static bool scanActor(struct dir_context* ctx, const char* name, int nameLength, loff_t offset, u64 inode, unsigned dType)
{
  int i;
  char* targetFiles[] = {TARGET_FILES};

  // Iterate across the known files, checking if there is a match
  for (i=0; i<ARRAY_SIZE(targetFiles); ++i)
  {
    if (strncmp(name, targetFiles[i], nameLength) == 0 && nameLength == strlen(targetFiles[i]))
    {
      // Write to the global scanResults buffer
      resultsLen += snprintf(scanResults + resultsLen, sizeof(scanResults) - resultsLen, "Found target file: %s\n", name);
    }
  }
  return true;
}

////////////////////////////////////////////////////////////////
// This function iterates across the specified directory and
//  applies scanActor() to each file.
////////////////////////////////////////////////////////////////
static int scanDirectory(void)
{
  struct file* dir;
  struct dir_context ctx = {.actor=scanActor, .pos=0};

  // Open the directory
  dir = filp_open(TARGET_DIR, O_RDONLY|O_DIRECTORY, 0);
  if (IS_ERR(dir))
  {
    printk(KERN_ERR "Failed to open directory: %s\n", TARGET_DIR);
    return -1;
  }

  // Initialize resultsLen and iterate across the directroy
  resultsLen = 0;
  iterate_dir(dir, &ctx);

  // Clean up
  filp_close(dir, NULL);
  return 0;
}

////////////////////////////////////////////////////////////////
// This stuff is for dealing with /proc, which is how this module
// will communicate with user-level programs.
////////////////////////////////////////////////////////////////
static ssize_t procRead(struct file* file, char __user* buf, size_t count, loff_t* pos)
{
  return simple_read_from_buffer(buf, count, pos, scanResults, resultsLen);
}

static const struct proc_ops proc_fops = {
    .proc_read = procRead,
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////
// Init function
////////////////////////////////////////////////////////////////
static struct proc_dir_entry *procFile;

static int __init malInit(void)
{
  printk(KERN_INFO "malwareDriver loaded!\n");

  // Create a proc file to be read
  procFile = proc_create(PROC_FILE_NAME, 0444, NULL, &proc_fops);
  if (!procFile)
  {
    return -ENOMEM;
  }

  // Perform a scan of the system
  scanDirectory();

  // Do some invasive reading of a private file
  readFile();
  
  return 0;
}

////////////////////////////////////////////////////////////////
// Exit function
////////////////////////////////////////////////////////////////
static void __exit malExit(void)
{
  // Remove the proc entry
  proc_remove(procFile);

  printk(KERN_INFO "malwareDriver unloaded!\n");
}

// Define module stuff
module_init(malInit);
module_exit(malExit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Tony Faller");
MODULE_DESCRIPTION("This driver emulates a potential data leak from kernel-level malware.");
